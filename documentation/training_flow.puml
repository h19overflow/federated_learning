@startuml Training to Results Flow
!theme plain
title Pneumonia Detection - Complete Training to Results Flow

' Participants
actor "User" as User
participant "React Frontend" as Frontend
participant "FastAPI\nEndpoint" as API
participant "Background\nTask" as Task
participant "Centralized\nTrainer" as Trainer
participant "Metrics\nCollector" as Metrics
database "PostgreSQL\nDatabase" as DB
participant "WebSocket\nServer" as WS
participant "Results\nAPI" as ResultsAPI

== Phase 1: Training Initialization ==

User -> Frontend: Upload dataset.zip\nClick "Start Training"
activate Frontend

Frontend -> API: POST /experiments/centralized/train\n(multipart/form-data)
activate API

note right of API
  Request Parameters:
  - data_zip: File
  - checkpoint_dir: String
  - logs_dir: String
  - experiment_name: String
  - csv_filename: String
end note

API -> API: prepare_zip()
note right of API
  1. Create temp directory
  2. Save uploaded file
  3. Extract ZIP contents
  4. Validate structure
end note

API -> Task: add_task()\nrun_centralized_training_task()
activate Task

API --> Frontend: 200 OK\n{"status": "queued",\n "experiment_name": "...",\n "checkpoint_dir": "...",\n "logs_dir": "..."}
deactivate API

Frontend -> Frontend: Show "Training queued" message
deactivate Frontend

== Phase 2: Training Start & Run Creation ==

Task -> Trainer: CentralizedTrainer()\n.train()
activate Trainer

Trainer -> Trainer: Load dataset\nCreate data splits

Trainer -> Metrics: on_train_start()
activate Metrics

Metrics -> DB: INSERT INTO runs\n(training_mode,\n status, start_time,\n wandb_id, source_path)
activate DB
DB --> Metrics: run_id = 123
deactivate DB

note right of Metrics
  Run created in database
  Status: "in_progress"
  Timestamp: Current time
end note

Metrics -> WS: send_metrics()\n{"type": "training_start",\n "run_id": 123,\n "experiment_name": "...",\n "max_epochs": 50}
activate WS

WS -> Frontend: Broadcast to all clients
activate Frontend

Frontend -> Frontend: Store run_id = 123\nUpdate UI: "Training started"
note right of Frontend
  WebSocket event received
  Run ID stored in state
  Progress bar initialized
end note
deactivate Frontend
deactivate WS
deactivate Metrics

== Phase 3: Training Loop (Each Epoch) ==

loop For each epoch (0 to N)

    Trainer -> Trainer: Train epoch\n(forward pass,\n backward pass,\n optimizer step)

    Trainer -> Trainer: Validation epoch\n(evaluate on val set)

    Trainer -> Metrics: on_validation_epoch_end()\n(epoch_metrics)
    activate Metrics

    note right of Metrics
      Metrics collected:
      - train_loss, val_loss
      - train_acc, val_acc
      - val_precision, val_recall
      - val_f1, val_auroc
    end note

    Metrics -> WS: send_epoch_end()\n{"type": "epoch_end",\n "epoch": current,\n "phase": "val",\n "metrics": {...}}
    activate WS

    WS -> Frontend: Broadcast metrics
    activate Frontend

    Frontend -> Frontend: Update progress bar\nDisplay current metrics
    note right of Frontend
      Real-time UI update:
      - Progress: epoch/total
      - Current loss/accuracy
      - Live training chart
    end note
    deactivate Frontend
    deactivate WS
    deactivate Metrics

end

== Phase 4: Training Completion & Metrics Persistence ==

Trainer -> Metrics: on_train_end()
activate Metrics

Metrics -> Metrics: Collect all epoch metrics\nCalculate best epoch

Metrics -> DB: persist_to_database()
activate DB

note right of DB
  Bulk insert all metrics:

  INSERT INTO run_metrics
  (run_id, metric_name,
   metric_value, step,
   dataset_type)
  VALUES
  (123, 'val_loss', 0.25, 0, 'validation'),
  (123, 'val_acc', 0.85, 0, 'validation'),
  (123, 'val_loss', 0.20, 1, 'validation'),
  ... [all epochs]
end note

DB --> Metrics: Success
deactivate DB

Metrics -> DB: UPDATE runs\nSET status = 'completed',\n end_time = NOW()\nWHERE id = 123
activate DB
DB --> Metrics: Updated
deactivate DB

Metrics -> WS: send_metrics()\n{"type": "training_end",\n "run_id": 123,\n "status": "completed",\n "best_epoch": 45,\n "best_val_recall": 0.95,\n "total_epochs": 50}
activate WS

WS -> Frontend: Broadcast completion
activate Frontend

Frontend -> Frontend: Switch to results view\nPass run_id = 123
note right of Frontend
  Training complete!
  Redirecting to results...
end note
deactivate WS

deactivate Metrics
deactivate Trainer
deactivate Task

== Phase 5: Results Fetching & Visualization ==

Frontend -> ResultsAPI: GET /api/runs/123/metrics
activate ResultsAPI

ResultsAPI -> DB: SELECT * FROM runs\nWHERE id = 123
activate DB
DB --> ResultsAPI: Run record
deactivate DB

ResultsAPI -> DB: SELECT * FROM run_metrics\nWHERE run_id = 123\nORDER BY step
activate DB
DB --> ResultsAPI: All metrics\n(~500 rows for 50 epochs)
deactivate DB

note right of ResultsAPI
  Transform database format:

  RunMetric rows:
  [{metric_name: 'val_loss',
    metric_value: 0.25,
    step: 0}, ...]

  ↓ Transform to ↓

  Frontend format:
  {final_metrics: {...},
   training_history: [...],
   metadata: {...}}
end note

ResultsAPI -> ResultsAPI: _transform_run_to_results()\nGroup by epoch\nExtract final metrics

ResultsAPI --> Frontend: 200 OK\n{"final_metrics": {...},\n "training_history": [...],\n "metadata": {...},\n "confusion_matrix": null}
deactivate ResultsAPI

Frontend -> Frontend: Render visualization:\n- Metrics cards\n- Training history charts\n- Confusion matrix\n- Metadata table
note right of Frontend
  Results displayed:
  - Final accuracy, precision, recall
  - Loss/Accuracy line charts
  - Epoch-by-epoch metrics table
  - Download options
end note

deactivate Frontend

@enduml
